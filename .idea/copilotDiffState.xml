<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/scala/Main.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Main.scala" />
              <option name="originalContent" value="import scalafx.animation.{KeyFrame, Timeline}&#10;import scalafx.application.JFXApp3&#10;import scalafx.application.JFXApp3.PrimaryStage&#10;import scalafx.beans.property.ObjectProperty&#10;import scalafx.scene.Scene&#10;import scalafx.stage.Screen&#10;import scalafx.util.Duration&#10;import scala.language.postfixOps&#10;&#10;object Main extends JFXApp3 {&#10;&#10;  override def start(): Unit = {&#10;&#10;    val numberOfParticles: Int = 1500 //1500&#10;    val particleRadius: Int = 3&#10;    val (boardWidth, boardHeight): (Int, Int) = (&#10;      Screen.primary.visualBounds.width.intValue,&#10;      Screen.primary.visualBounds.height.intValue&#10;    )&#10;&#10;    val particlesList: ObjectProperty[List[(Particle, Direction)]] = ObjectProperty(&#10;      List.fill(numberOfParticles)(&#10;        (Particle.randomPosition(particleRadius, boardWidth, boardHeight), Particle.randomDirection)&#10;      )&#10;    )&#10;&#10;    stage = new PrimaryStage {&#10;      title = &quot;Particles Simulator&quot;&#10;      width = boardWidth&#10;      height = boardHeight&#10;      scene = new Scene {&#10;        content = particlesList.value.map(_._1.draw)&#10;        particlesList.onChange {&#10;          content = particlesList.value.map(_._1.draw)&#10;        }&#10;      }&#10;    }&#10;&#10;    new Timeline {&#10;      keyFrames = List(&#10;        KeyFrame(&#10;          time = Duration(50),&#10;          onFinished = _ =&gt; {&#10;            // Étape 1 : Déplacer toutes les particules&#10;            val movedParticles = particlesList.value.map { case (particle, direction) =&gt;&#10;              val movedParticle = particle.move(direction, boardWidth, boardHeight, particleRadius)&#10;              (movedParticle, direction)&#10;            }&#10;            &#10;            // Étape 2 : Vérifier les collisions et changer les directions si nécessaire&#10;            val updatedParticles = movedParticles.map { case (particle, direction) =&gt;&#10;              val otherParticles = movedParticles.map(_._1).filter(_ != particle)&#10;              &#10;              // Vérifier si une autre particule est dans le périmètre (rayon * 2)&#10;              if (particle.hasCollision(otherParticles, particleRadius * 2)) {&#10;                // Si collision, changer de direction pour la prochaine frame&#10;                (particle, Particle.randomDirection)&#10;              } else {&#10;                // Sinon, garder la même direction&#10;                (particle, direction)&#10;              }&#10;            }&#10;            &#10;            particlesList.update(updatedParticles)&#10;          }&#10;        )&#10;      )&#10;      cycleCount = Timeline.Indefinite&#10;    }.play()&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import scalafx.animation.{KeyFrame, Timeline}&#10;import scalafx.application.JFXApp3&#10;import scalafx.application.JFXApp3.PrimaryStage&#10;import scalafx.beans.property.ObjectProperty&#10;import scalafx.scene.Scene&#10;import scalafx.stage.Screen&#10;import scalafx.util.Duration&#10;import scala.language.postfixOps&#10;&#10;object Main extends JFXApp3 {&#10;&#10;  override def start(): Unit = {&#10;&#10;    val numberOfParticles: Int = 1500 //1500&#10;    val particleRadius: Int = 3&#10;    val (boardWidth, boardHeight): (Int, Int) = (&#10;      Screen.primary.visualBounds.width.intValue,&#10;      Screen.primary.visualBounds.height.intValue&#10;    )&#10;&#10;    val particlesList: ObjectProperty[List[(Particle, Direction)]] = ObjectProperty(&#10;      List.fill(numberOfParticles)(&#10;        (Particle.randomPosition(particleRadius, boardWidth, boardHeight), Particle.randomDirection)&#10;      )&#10;    )&#10;&#10;    stage = new PrimaryStage {&#10;      title = &quot;Particles Simulator&quot;&#10;      width = boardWidth&#10;      height = boardHeight&#10;      scene = new Scene {&#10;        content = particlesList.value.map(_._1.draw)&#10;        particlesList.onChange {&#10;          content = particlesList.value.map(_._1.draw)&#10;        }&#10;      }&#10;    }&#10;&#10;    new Timeline {&#10;      keyFrames = List(&#10;        KeyFrame(&#10;          time = Duration(50),&#10;          onFinished = _ =&gt; {&#10;            // Étape 1 : Déplacer toutes les particules&#10;            val movedParticles = particlesList.value.map { case (particle, direction) =&gt;&#10;              val movedParticle = particle.move(direction, boardWidth, boardHeight, particleRadius)&#10;              (movedParticle, direction)&#10;            }&#10;            &#10;            // Étape 2 : Vérifier les collisions et changer les directions si nécessaire&#10;            val updatedParticles = movedParticles.map { case (particle, direction) =&gt;&#10;              val otherParticles = movedParticles.map(_._1).filter(_ != particle)&#10;              &#10;              // Vérifier si une autre particule est dans le périmètre (rayon * 2)&#10;              if (particle.hasCollision(otherParticles, particleRadius * 2)) {&#10;                // Si collision, changer de direction pour la prochaine frame&#10;                (particle, Particle.randomDirection)&#10;              } else {&#10;                // Sinon, garder la même direction&#10;                (particle, direction)&#10;              }&#10;            }&#10;            &#10;            particlesList.update(updatedParticles)&#10;          }&#10;        )&#10;      )&#10;      cycleCount = Timeline.Indefinite&#10;    }.play()&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/scala/Particle.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Particle.scala" />
              <option name="originalContent" value="import scalafx.scene.paint.Color&#10;import scalafx.scene.shape.Circle&#10;&#10;import scala.util.Random&#10;&#10;case class Particle(particleRadius: Int, particleX: Int, particleY: Int, color: Color) {&#10;&#10;  def draw: Circle = {&#10;    new Circle {&#10;      centerX = particleX&#10;      centerY = particleY&#10;      radius = particleRadius&#10;      fill = color&#10;    }&#10;  }&#10;  &#10;  def hasCollision(otherParticles: List[Particle], collisionRadius: Int): Boolean = {&#10;    otherParticles.exists { other =&gt;&#10;      if (other == this) false&#10;      else {&#10;        val dx = other.particleX - particleX&#10;        val dy = other.particleY - particleY&#10;        val distanceSquared = dx * dx + dy * dy&#10;        val minDistance = collisionRadius + collisionRadius&#10;        distanceSquared &lt;= minDistance * minDistance&#10;      }&#10;    }&#10;  }&#10;&#10;  def move(direction: Direction, boardWidth: Int, boardHeight: Int, step: Int): Particle = {&#10;    val (nx, ny) = direction match {&#10;      case Direction.NORTH =&gt; (particleX, particleY - step)&#10;      case Direction.SOUTH =&gt; (particleX, particleY + step)&#10;      case Direction.EAST =&gt; (particleX + step, particleY)&#10;      case Direction.WEST =&gt; (particleX - step, particleY)&#10;      case Direction.NORTHEAST =&gt; (particleX + step, particleY - step)&#10;      case Direction.NORTHWEST =&gt; (particleX - step, particleY - step)&#10;      case Direction.SOUTHEAST =&gt; (particleX + step, particleY + step)&#10;      case Direction.SOUTHWEST =&gt; (particleX - step, particleY + step)&#10;    }&#10;&#10;    val newParticleX = if (nx &lt; 0) boardWidth + nx&#10;                       else if (nx &gt; boardWidth) nx - boardWidth&#10;                       else nx&#10;&#10;    val newParticleY = if (ny &lt; 0) boardHeight + ny&#10;                       else if (ny &gt; boardHeight) ny - boardHeight&#10;                       else ny&#10;&#10;    copy(particleX = newParticleX, particleY = newParticleY)&#10;  }&#10;}&#10;&#10;object Particle {&#10;  def randomPosition(particleRadius: Int, screenWidth: Int, screenHeight: Int): Particle =&#10;    Particle(particleRadius, Random.nextInt(screenWidth), Random.nextInt(screenHeight), randomColor)&#10;&#10;  def randomDirection: Direction = Random.nextInt(8) match {&#10;    case 0 =&gt; Direction.NORTH&#10;    case 1 =&gt; Direction.SOUTH&#10;    case 2 =&gt; Direction.EAST&#10;    case 3 =&gt; Direction.WEST&#10;    case 4 =&gt; Direction.NORTHEAST&#10;    case 5 =&gt; Direction.NORTHWEST&#10;    case 6 =&gt; Direction.SOUTHEAST&#10;    case _ =&gt; Direction.SOUTHWEST&#10;  }&#10;&#10;  private def randomColor: Color = Color(&#10;    Random.nextDouble(),&#10;    Random.nextDouble(),&#10;    Random.nextDouble(),&#10;    1&#10;  )&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import scalafx.scene.paint.Color&#10;import scalafx.scene.shape.Circle&#10;&#10;import scala.util.Random&#10;&#10;case class Particle(particleRadius: Int, particleX: Int, particleY: Int, color: Color) {&#10;&#10;  def draw: Circle = {&#10;    new Circle {&#10;      centerX = particleX&#10;      centerY = particleY&#10;      radius = particleRadius&#10;      fill = color&#10;    }&#10;  }&#10;  &#10;  def hasCollision(otherParticles: List[Particle], collisionRadius: Int): Boolean = {&#10;    otherParticles.exists { other =&gt;&#10;      if (other == this) false&#10;      else {&#10;        val dx = other.particleX - particleX&#10;        val dy = other.particleY - particleY&#10;        val distanceSquared = dx * dx + dy * dy&#10;        val minDistance = collisionRadius + collisionRadius&#10;        distanceSquared &lt;= minDistance * minDistance&#10;      }&#10;    }&#10;  }&#10;&#10;  def move(direction: Direction, boardWidth: Int, boardHeight: Int, step: Int): Particle = {&#10;    val (nx, ny) = direction match {&#10;      case Direction.NORTH =&gt; (particleX, particleY - step)&#10;      case Direction.SOUTH =&gt; (particleX, particleY + step)&#10;      case Direction.EAST =&gt; (particleX + step, particleY)&#10;      case Direction.WEST =&gt; (particleX - step, particleY)&#10;      case Direction.NORTHEAST =&gt; (particleX + step, particleY - step)&#10;      case Direction.NORTHWEST =&gt; (particleX - step, particleY - step)&#10;      case Direction.SOUTHEAST =&gt; (particleX + step, particleY + step)&#10;      case Direction.SOUTHWEST =&gt; (particleX - step, particleY + step)&#10;    }&#10;&#10;    val newParticleX = if (nx &lt; 0) boardWidth + nx&#10;                       else if (nx &gt; boardWidth) nx - boardWidth&#10;                       else nx&#10;&#10;    val newParticleY = if (ny &lt; 0) boardHeight + ny&#10;                       else if (ny &gt; boardHeight) ny - boardHeight&#10;                       else ny&#10;&#10;    copy(particleX = newParticleX, particleY = newParticleY)&#10;  }&#10;}&#10;&#10;object Particle {&#10;  def randomPosition(particleRadius: Int, screenWidth: Int, screenHeight: Int): Particle =&#10;    Particle(particleRadius, Random.nextInt(screenWidth), Random.nextInt(screenHeight), randomColor)&#10;&#10;  def randomDirection: Direction = Random.nextInt(8) match {&#10;    case 0 =&gt; Direction.NORTH&#10;    case 1 =&gt; Direction.SOUTH&#10;    case 2 =&gt; Direction.EAST&#10;    case 3 =&gt; Direction.WEST&#10;    case 4 =&gt; Direction.NORTHEAST&#10;    case 5 =&gt; Direction.NORTHWEST&#10;    case 6 =&gt; Direction.SOUTHEAST&#10;    case _ =&gt; Direction.SOUTHWEST&#10;  }&#10;&#10;  private def randomColor: Color = Color(&#10;    Random.nextDouble(),&#10;    Random.nextDouble(),&#10;    Random.nextDouble(),&#10;    1&#10;  )&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>